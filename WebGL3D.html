<!DOCTYPE html>
<meta charset="UTF-8">
<html>

  <!--
    File: WebGL3D.html
    Author: John Kucera (Template diskplay.html provided by Prof. Amitava Karmaker)
    Date: October 7, 2021
    Purpose: This HTML/Javascript program uses webGL to create a unique 3D animated
    scene composed of WebGL graphic components. It has 10 different objects, has
    dimensions of 700x700, different colors of lights from different positions, 3 different
    textures, and radio buttons/checkboxes for controlling the animation, lights, and textures.
    The shapes have different animated transformations, consisting of rotations and 
    translations. They create a scene with a Boat, Water, Grass, Lifebuoy, Lilypad,
    2 Clouds, 2 fish and Sun.
  -->

  <head>
    <title>Sea Scene - John Kucera</title>
    <style>
      body {
        background-color: #dadada;
      }
      label {
        white-space: pre;
        margin-left: 25px;
      }
    </style>

    <!-- Vertex Shader -->

    <script type="x-shader/x-vertex" id="vshader-source">
      attribute vec3 a_coords;
      attribute vec3 a_normal;
      attribute vec2 a_texCoords;
      uniform mat4 modelview;
      uniform mat4 projection;
      varying vec3 v_normal;
      varying vec3 v_eyeCoords;
      varying vec2 v_texCoords;
      void main() {
          vec4 coords = vec4(a_coords,1.0);
          vec4 eyeCoords = modelview * coords;
          gl_Position = projection * eyeCoords;
          v_normal = normalize(a_normal);
          v_eyeCoords = eyeCoords.xyz/eyeCoords.w;
          v_texCoords = a_texCoords;
      }
    </script>

    <!-- Fragment Shader, No texture -->

    <script type="x-shader/x-fragment" id="fshader-source">
      #ifdef GL_FRAGMENT_PRECISION_HIGH
         precision highp float;
      #else
         precision mediump float;
      #endif
      struct MaterialProperties {
          vec4 diffuseColor;
          vec3 specularColor;
          vec3 emissiveColor;
          float specularExponent;
      };
      struct LightProperties {
          bool enabled;
          vec4 position;
          vec3 color;
      };
      uniform MaterialProperties material; // do two-sided lighting, but assume front and back materials are the same
      uniform LightProperties lights[4];
      uniform mat3 normalMatrix;
      uniform sampler2D texture;
      varying vec3 v_normal;
      varying vec3 v_eyeCoords;
      varying vec2 v_texCoords;
      vec3 lightingEquation( LightProperties light, MaterialProperties material,
                                  vec3 eyeCoords, vec3 N, vec3 V ) {
             // N is normal vector, V is direction to viewer.
          vec3 L, R; // Light direction and reflected light direction.
          if ( light.position.w == 0.0 ) {
              L = normalize( light.position.xyz );
          }
          else {
              L = normalize( light.position.xyz/light.position.w - v_eyeCoords );
          }
          if (dot(L,N) <= 0.0) {
              return vec3(0.0);
          }
          vec3 reflection = dot(L,N) * light.color * material.diffuseColor.rgb;
          R = -reflect(L,N);
          if (dot(R,V) > 0.0) {
              float factor = pow(dot(R,V),material.specularExponent);
              reflection += factor * material.specularColor * light.color;
          }
           return reflection;

      }
      void main() {
          vec3 normal = normalize( normalMatrix*v_normal );
          vec3 viewDirection = normalize( -v_eyeCoords);  // (Assumes a perspective projection.)
          vec3 color = material.emissiveColor;

          for (int i = 0; i < 4; i++) {
              if (lights[i].enabled) {
                  if (gl_FrontFacing) {
                      color += lightingEquation( lights[i], material, v_eyeCoords,
                                                      normal, viewDirection);
                  }
                  else {
                      color += lightingEquation( lights[i], material, v_eyeCoords,
                                                      -normal, viewDirection);
                  }
              }
          }

          gl_FragColor = vec4(color,material.diffuseColor.a);
      }
    </script>

    <!-- Fragment Shader, Texture -->

    <script type="x-shader/x-fragment" id="fshader-source-t">
      #ifdef GL_FRAGMENT_PRECISION_HIGH
         precision highp float;
      #else
         precision mediump float;
      #endif
      struct MaterialProperties {
          vec4 diffuseColor;
          vec3 specularColor;
          vec3 emissiveColor;
          float specularExponent;
      };
      struct LightProperties {
          bool enabled;
          vec4 position;
          vec3 color;
      };
      uniform MaterialProperties material; // do two-sided lighting, but assume front and back materials are the same
      uniform LightProperties lights[4];
      uniform mat3 normalMatrix;
      uniform sampler2D texture;
      varying vec3 v_normal;
      varying vec3 v_eyeCoords;
      varying vec2 v_texCoords;
      vec3 lightingEquation( LightProperties light, MaterialProperties material,
                                  vec3 eyeCoords, vec3 N, vec3 V ) {
             // N is normal vector, V is direction to viewer.
          vec3 L, R; // Light direction and reflected light direction.
          if ( light.position.w == 0.0 ) {
              L = normalize( light.position.xyz );
          }
          else {
              L = normalize( light.position.xyz/light.position.w - v_eyeCoords );
          }
          if (dot(L,N) <= 0.0) {
              return vec3(0.0);
          }
          vec3 reflection = dot(L,N) * light.color * material.diffuseColor.rgb;
          R = -reflect(L,N);
          if (dot(R,V) > 0.0) {
              float factor = pow(dot(R,V),material.specularExponent);
              reflection += factor * material.specularColor * light.color;
          }
           return reflection;

      }
      void main() {
          vec3 normal = normalize( normalMatrix*v_normal );
          vec3 viewDirection = normalize( -v_eyeCoords);  // (Assumes a perspective projection.)
          vec3 color = material.emissiveColor;

          for (int i = 0; i < 4; i++) {
              if (lights[i].enabled) {
                  if (gl_FrontFacing) {
                      color += lightingEquation( lights[i], material, v_eyeCoords,
                                                      normal, viewDirection);
                  }
                  else {
                      color += lightingEquation( lights[i], material, v_eyeCoords,
                                                      -normal, viewDirection);
                  }
              }
          }

          gl_FragColor = texture2D(texture, v_texCoords);
      }
    </script>

    <!-- Importing other Javascript files that provide WebGL functionality -->

    <script src="gl-matrix-min.js"></script>
    <script src="trackball-rotator.js"></script>
    <script src="basic-object-models-IFS.js"></script>
    <script>

      "use strict";

      var gl;   // The webgl context.

      var a_coords_loc;         // Location of the a_coords attribute variable in the shader program.
      var a_normal_loc;         // Location of a_normal attribute
      var a_texcoords_loc;

      var u_modelview;       // Locations for uniform matrices
      var u_projection;
      var u_normalMatrix;
      var u_texture;

      var u_material;     // An object tolds uniform locations for the material.
      var u_lights;       // An array of objects that holds uniform locations for light properties.

      var projection = mat4.create();    // projection matrix
      var modelview;                     // modelview matrix; value comes from rotator
      var normalMatrix = mat3.create();  // matrix, derived from modelview matrix, for transforming normal vectors

      var rotator;  // A TrackballRotator to implement rotation by mouse.

      var textureLoaded;
      var textureUrl = [
        "textures/burning+hot+lava.png",
        "textures/clear+sea+water.png",
        "textures/hedge+wall.png"
      ];
      var texture;

      var frameNumber = 0;  // frame number during animation (actually only goes up by 0.5 per frame)

      var torus, sphere, cone, cylinder, disk, ring, cube;  // basic objects, created using function createModel

      var matrixStack = [];           // A stack of matrices for implementing hierarchical graphics.

      var currentColor = [1, 1, 1, 1];   // The current diffuseColor; render() functions in the basic objects set
      // the diffuse color to currentColor when it is called before drawing the object.
      // Other color properties, which don't change often are handled elsewhere.

      var sunRotation = Math.PI / 2 - 1.5;    // Angle at which sun is in rotation
      var cloudRotation = Math.PI / 2 + 1.5;  // Angle at which cloud is in rotation
      var fishRotation = Math.PI / 2 - 2;     // Angle at which fish is in rotation
      var sunlight = true;                    // if true, sunlight is on
      var waterlight = true;                  // if true, waterlight is on
      var bobDistance = 0;                    // stores position of objects bobbing on water

      /**
       * function draw(): Makes initial settings and calls all drawing functions
       */
      function draw() {
        gl.clearColor(0, 0, 0, 0.7); // Gray background
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        if (!textureLoaded) return;

        mat4.perspective(projection, Math.PI / 4, 1, 1, 50);
        gl.uniformMatrix4fv(u_projection, false, projection);

        modelview = rotator.getViewMatrix();

        // Calling all objects and lights
        lights();
        boat();         // Object 1
        lifebuoy();     // Object 2
        lilypad();      // Object 3
        grass();        // Object 4
        fish();         // Objects 5, 6
        water();        // Object 7
        sun();          // Object 8
        clouds();       // Objects 9, 10
      } // end of function

      /**
       * function lights(): Creates lights with colors and positions from sun and water
       */
      function lights() {
        // Sunlight
        if (sunlight) { // Checkbox checked
          pushMatrix();
          gl.uniform1i(u_lights[0].enabled, 1);
          mat4.rotateY(modelview, modelview, sunRotation);
          setLightPosition(u_lights[0].position, modelview, [-4, 7, 1, 1]);
          gl.uniform3f(u_lights[0].color, 0.8, 0.8, 0);
          popMatrix();
        } 
        else { // Checkbox unchecked, no sunlight
          pushMatrix();
          gl.uniform1i(u_lights[0].enabled, 1);
          mat4.rotateY(modelview, modelview, sunRotation);
          setLightPosition(u_lights[0].position, modelview, [-4, 7, 1, 1]);
          gl.uniform3f(u_lights[0].color, 0, 0, 0);
          popMatrix();
        }

        // Waterlight
        if (waterlight) { // Checkbox checked
          gl.uniform1i(u_lights[1].enabled, 1);
          setLightPosition(u_lights[1].position, modelview, [0, -5, 0, 1]);
          gl.uniform3f(u_lights[1].color, 0, 0, 1);
        }
        else { // Checkbox unchecked
          gl.uniform1i(u_lights[1].enabled, 1);
          setLightPosition(u_lights[1].position, modelview, [0, -5, 0, 1]);
          gl.uniform3f(u_lights[1].color, 0, 0, 0);
        }
      } // end of function

      /**
       * function setLightPosition(): Allows light to more easily be positioned
       */
      function setLightPosition(u_position_loc, modelview, lightPosition)
      {
        var transformedPosition = new Float32Array(4);
        vec4.transformMat4(transformedPosition, lightPosition, modelview);
        gl.uniform4fv(u_position_loc, transformedPosition);
      } // end of function

      /**
       * function boat(): Creates boat, flagpole, and flag
       */
      function boat() {
        // Boat underside
        pushMatrix();
        mat4.translate(modelview, modelview, [0, -3.5 + bobDistance, -4]);
        mat4.scale(modelview, modelview, [6, 0.4, 3]);
        gl.uniform3f(u_material.emissiveColor, 0.5, 0.3, 0);
        cube.render();
        popMatrix();

        // Boat left side
        pushMatrix();
        mat4.translate(modelview, modelview, [-3, -2.7 + bobDistance, -4]);
        mat4.scale(modelview, modelview, [0.4, 2, 3]);
        cube.render();
        popMatrix();

        // Boat right side
        pushMatrix();
        mat4.translate(modelview, modelview, [3, -2.7 + bobDistance, -4]);
        mat4.scale(modelview, modelview, [0.4, 2, 3]);
        cube.render();
        popMatrix();

        // Boat back side
        pushMatrix();
        mat4.translate(modelview, modelview, [0, -2.7 + bobDistance, -5.3]);
        mat4.scale(modelview, modelview, [6, 2, 0.4]);
        cube.render();
        popMatrix();

        // Boat front side
        pushMatrix();
        mat4.translate(modelview, modelview, [0, -2.7 + bobDistance, -2.7]);
        mat4.scale(modelview, modelview, [6, 2, 0.4]);
        cube.render();
        gl.uniform3f(u_material.emissiveColor, 0, 0, 0);
        popMatrix();

        // Flagpole
        pushMatrix();
        mat4.translate(modelview, modelview, [2.2, 8.3 + bobDistance, -4]);
        mat4.rotate(modelview, modelview, 0.5 * Math.PI, [1, 0, 0]);
        mat4.scale(modelview, modelview, [0.2, 0.2, 6]);
        gl.uniform3f(u_material.diffuseColor, 1, 0, 0);
        cylinder.render();
        gl.uniform3f(u_material.diffuseColor, 0, 0, 0);
        popMatrix();

        // Flag
        pushMatrix();
        mat4.translate(modelview, modelview, [0, 0.4 + bobDistance, -4]);
        mat4.scale(modelview, modelview, [4, 3, 0.2]);
        gl.uniform3f(u_material.diffuseColor, 1, 1, 1);
        cube.render();
        gl.uniform3f(u_material.diffuseColor, 0, 0, 0);
        popMatrix();
      } // end of function

      /**
       * function lifebuoy(): Creates lifebuoy
       */
      function lifebuoy() {
        pushMatrix();
        mat4.translate(modelview, modelview, [3, -3.5 - bobDistance / 2, 3]);
        mat4.rotate(modelview, modelview, 0.5 * Math.PI, [1, 0, 0]);
        mat4.scale(modelview, modelview, [1, 1, 1]);
        gl.uniform3f(u_material.emissiveColor, 0.7, 0, 0.3);
        torus.render();
        gl.uniform3f(u_material.emissiveColor, 0, 0, 0);
        popMatrix();
      } // end of function

      /**
       * function lilypad(): Creates lilypad
       */
      function lilypad() {
        pushMatrix();
        mat4.translate(modelview, modelview, [-3.5, -3.44 + bobDistance / 4, 1]);
        mat4.rotate(modelview, modelview, 0.5 * Math.PI, [1, 0, 0]);
        mat4.scale(modelview, modelview, [0.2, 0.2, 0.2]);
        gl.uniform3f(u_material.emissiveColor, 0, 0.8, 0.2);
        disk.render();
        gl.uniform3f(u_material.emissiveColor, 0, 0, 0);
        popMatrix();
      } // end of function

      /**
       * function grass(): Creates 4 blades of grass
       */
      function grass() {
        // Blade 1
        pushMatrix();
        mat4.translate(modelview, modelview, [-3, -3.6, 4]);
        mat4.rotate(modelview, modelview, 0.5 * Math.PI, [0, 0, 1]);
        mat4.rotate(modelview, modelview, 0.5 * Math.PI, [0, 1, 0]);
        mat4.scale(modelview, modelview, [0.2, 0.2, 1.5]);
        gl.uniform3f(u_material.emissiveColor, 0, 0.9, 0);
        cone.render();
        popMatrix();

        // Blade 2
        pushMatrix();
        mat4.translate(modelview, modelview, [-3.3, -3.6, 4.2]);
        mat4.rotate(modelview, modelview, 0.5 * Math.PI, [0, 0, 1]);
        mat4.rotate(modelview, modelview, 0.5 * Math.PI, [0, 1, 0]);
        mat4.scale(modelview, modelview, [0.2, 0.2, 2]);
        cone.render();
        gl.uniform3f(u_material.emissiveColor, 0, 0, 0);
        popMatrix();

        // Blade 3
        pushMatrix();
        mat4.translate(modelview, modelview, [-3.1, -3.6, 3.8]);
        mat4.rotate(modelview, modelview, 0.5 * Math.PI, [0, 0, 1]);
        mat4.rotate(modelview, modelview, 0.5 * Math.PI, [0, 1, 0]);
        mat4.scale(modelview, modelview, [0.2, 0.2, 1]);
        gl.uniform3f(u_material.emissiveColor, 0, 0.8, 0);
        cone.render();
        popMatrix();

        // Blade 4
        pushMatrix();
        mat4.translate(modelview, modelview, [-3, -3.6, 4.4]);
        mat4.rotate(modelview, modelview, 0.5 * Math.PI, [0, 0, 1]);
        mat4.rotate(modelview, modelview, 0.5 * Math.PI, [0, 1, 0]);
        mat4.scale(modelview, modelview, [0.2, 0.2, 1.3]);
        cone.render();
        gl.uniform3f(u_material.emissiveColor, 0, 0, 0);
        popMatrix();
      } // end of function

      /**
       * function fish(): Creates 2 fish
       */
      function fish() {
        // Fish 1
        pushMatrix();
        mat4.rotateY(modelview, modelview, fishRotation);
        mat4.translate(modelview, modelview, [1, -3.3, 1]);
        mat4.scale(modelview, modelview, [0.1, 0.05, 0.1]);
        gl.uniform3f(u_material.emissiveColor, 0.5, 0, 0.8);
        disk.render();
        gl.uniform3f(u_material.emissiveColor, 0, 0, 0);
        popMatrix();

        pushMatrix();
        mat4.rotateY(modelview, modelview, fishRotation);
        mat4.translate(modelview, modelview, [1.6, -3.3, 1]);
        mat4.scale(modelview, modelview, [0.02, 0.05, 0.1]);
        gl.uniform3f(u_material.emissiveColor, 0.5, 0, 0.8);
        disk.render();
        gl.uniform3f(u_material.emissiveColor, 0, 0, 0);
        popMatrix();

        // Fish 2
        pushMatrix();
        mat4.rotateY(modelview, modelview, fishRotation + 3);
        mat4.translate(modelview, modelview, [1, -3.3, 1]);
        mat4.scale(modelview, modelview, [0.2, 0.04, 0.1]);
        gl.uniform3f(u_material.emissiveColor, 1, 0.3, 0);
        disk.render();
        gl.uniform3f(u_material.emissiveColor, 0, 0, 0);
        popMatrix();

        pushMatrix();
        mat4.rotateY(modelview, modelview, fishRotation + 3);
        mat4.translate(modelview, modelview, [1.6, -3.3, 1]);
        mat4.scale(modelview, modelview, [0.1, 0.07, 0.1]);
        gl.uniform3f(u_material.emissiveColor, 1, 0.3, 0);
        disk.render();
        gl.uniform3f(u_material.emissiveColor, 0, 0, 0);
        popMatrix();
      } // end of function

      /**
       * function water(): Creates block of water
       */
      function water() {
        pushMatrix();
        mat4.translate(modelview, modelview, [0, -4, -0.5]);
        mat4.scale(modelview, modelview, [10, 1, 11.5]);
        gl.uniform3f(u_material.emissiveColor, 0, 0.3, 0.9);
        cube.render();
        gl.uniform3f(u_material.emissiveColor, 0, 0, 0);
        popMatrix();
      } // end of function

      /**
       * function sun(): Creates sun
       */
      function sun() {
        pushMatrix();
        mat4.rotateY(modelview, modelview, sunRotation);
        mat4.translate(modelview, modelview, [-4, 7, 1]);
        mat4.scale(modelview, modelview, [1.5, 1.5, 1.5]);
        gl.uniform3f(u_material.emissiveColor, 1, 1, 0);
        sphere.render();
        gl.uniform3f(u_material.emissiveColor, 0, 0, 0);
        popMatrix();
      } // end of function

      /**
       * function clouds(): Creates 2 clouds
       */
      function clouds() {
        // Cloud 1
        pushMatrix();
        mat4.rotateY(modelview, modelview, cloudRotation);
        mat4.translate(modelview, modelview, [4, 4, 1]);
        mat4.scale(modelview, modelview, [1.2, 1, 1.5]);
        gl.uniform3f(u_material.emissiveColor, 0.5, 0.5, 0.5);
        sphere.render();
        popMatrix();

        pushMatrix();
        mat4.rotateY(modelview, modelview, cloudRotation);
        mat4.translate(modelview, modelview, [4, 4, 0]);
        mat4.scale(modelview, modelview, [1, 0.8, 1.2]);
        sphere.render();
        popMatrix();

        // Cloud 2
        pushMatrix();
        mat4.rotateY(modelview, modelview, cloudRotation);
        mat4.translate(modelview, modelview, [1, 4, -5]);
        mat4.scale(modelview, modelview, [1.7, 1, 1.2]);
        sphere.render();
        popMatrix();

        pushMatrix();
        mat4.rotateY(modelview, modelview, cloudRotation);
        mat4.translate(modelview, modelview, [3, 4, -5]);
        mat4.scale(modelview, modelview, [1.3, 0.8, 1.2]);
        sphere.render();
        popMatrix();

        pushMatrix();
        mat4.rotateY(modelview, modelview, cloudRotation);
        mat4.translate(modelview, modelview, [-1, 4, -5]);
        mat4.scale(modelview, modelview, [1.3, 0.8, 1.2]);
        sphere.render();
        gl.uniform3f(u_material.emissiveColor, 0, 0, 0);
        popMatrix();
      } // end of function

      /**
       *  Push a copy of the current modelview matrix onto the matrix stack.
       */
      function pushMatrix() {
        matrixStack.push(mat4.clone(modelview));
      }

      /**
       *  Restore the modelview matrix to a value popped from the matrix stack.
       */
      function popMatrix() {
        modelview = matrixStack.pop();
      }

      /**
       *  Create one of the basic objects.  The modelData holds the data for
       *  an IFS using the structure from basic-objects-IFS.js.  This function
       *  creates VBOs to hold the coordinates, normal vectors, and indices
       *  from the IFS, and it loads the data into those buffers.  The function
       *  creates a new object whose properties are the identifies of the
       *  VBOs.  The new object also has a function, render(), that can be called to
       *  render the object, using all the data from the buffers.  That object
       *  is returned as the value of the function.  (The second parameter,
       *  xtraTranslate, is there because this program was ported from a Java
       *  version where cylinders were created in a different position, with
       *  the base on the xy-plane instead of with their center at the origin.
       *  The xtraTranslate parameter is a 3-vector that is applied as a
       *  translation to the rendered object.  It is used to move the cylinders
       *  into the position expected by the code that was ported from Java.)
       */
      function createModel(modelData, xtraTranslate) {
        var model = {};
        model.coordsBuffer = gl.createBuffer();
        model.normalBuffer = gl.createBuffer();
        model.texCoordsBuffer = gl.createBuffer();
        model.indexBuffer = gl.createBuffer();
        model.count = modelData.indices.length;
        if (xtraTranslate)
          model.xtraTranslate = xtraTranslate;
        else
          model.xtraTranslate = null;
        gl.bindBuffer(gl.ARRAY_BUFFER, model.coordsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexPositions, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, model.normalBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexNormals, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ARRAY_BUFFER, model.texCoordsBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexTextureCoords, gl.STATIC_DRAW);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, modelData.indices, gl.STATIC_DRAW);
        model.render = function() {  // This function will render the object.
          // Since the buffer from which we are taking the coordinates and normals
          // change each time an object is drawn, we have to use gl.vertexAttribPointer
          // to specify the location of the data. And to do that, we must first
          // bind the buffer that contains the data.  Similarly, we have to
          // bind this object's index buffer before calling gl.drawElements.
          gl.bindBuffer(gl.ARRAY_BUFFER, this.coordsBuffer);
          gl.vertexAttribPointer(a_coords_loc, 3, gl.FLOAT, false, 0, 0);
          gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
          gl.vertexAttribPointer(a_normal_loc, 3, gl.FLOAT, false, 0, 0);
          gl.bindBuffer(gl.ARRAY_BUFFER, this.texCoordsBuffer);
          gl.vertexAttribPointer(a_texcoords_loc, 2, gl.FLOAT, false, 0, 0);
          gl.uniform4fv(u_material.diffuseColor, currentColor);
          if (this.xtraTranslate) {
            pushMatrix();
            mat4.translate(modelview, modelview, this.xtraTranslate);
          }
          gl.uniformMatrix4fv(u_modelview, false, modelview);
          mat3.normalFromMat4(normalMatrix, modelview);
          gl.uniformMatrix3fv(u_normalMatrix, false, normalMatrix);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
          gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);
          if (this.xtraTranslate) {
            popMatrix();
          }
        };
        return model;
      }

      function loadTexture(imgsrc) {
        textureLoaded = false;
        draw();
        var img = new Image();
        img.onload = function () {
          try {
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
          } catch (e) {
            document.getElementById("message").innerHTML =
              "<b>SORRY, can't access texture image.  Note that some<br>browsers can't use a texture from a local disk.</b>";
            return;
          }
          gl.generateMipmap(gl.TEXTURE_2D);
          textureLoaded = true;
          if (!animating) draw();
        };
        img.onerror = function () {
          throw new Error("something went wrong with loading the image");
        };
        img.src = textureUrl[imgsrc];
      }

      /* Creates a program for use in the WebGL context gl, and returns the
       * identifier for that program.  If an error occurs while compiling or
       * linking the program, an exception of type String is thrown.  The error
       * string contains the compilation or linking error.  If no error occurs,
       * the program identifier is the return value of the function.
       *    The second and third parameters are the id attributes for <script>
       * elementst that contain the source code for the vertex and fragment
       * shaders.
       */
      function createProgram(gl, vertexShaderID, fragmentShaderID) {
        function getTextContent(elementID) {
          // This nested function retrieves the text content of an
          // element on the web page.  It is used here to get the shader
          // source code from the script elements that contain it.
          var element = document.getElementById(elementID);
          var node = element.firstChild;
          var str = "";
          while (node) {
            if (node.nodeType == 3) // this is a text node
              str += node.textContent;
            node = node.nextSibling;
          }
          return str;
        }
        try {
          var vertexShaderSource = getTextContent(vertexShaderID);
          var fragmentShaderSource = getTextContent(fragmentShaderID);
        }
        catch (e) {
          throw "Error: Could not get shader source code from script elements.";
        }
        var vsh = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vsh, vertexShaderSource);
        gl.compileShader(vsh);
        if (!gl.getShaderParameter(vsh, gl.COMPILE_STATUS)) {
          throw "Error in vertex shader:  " + gl.getShaderInfoLog(vsh);
        }
        var fsh = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fsh, fragmentShaderSource);
        gl.compileShader(fsh);
        if (!gl.getShaderParameter(fsh, gl.COMPILE_STATUS)) {
          throw "Error in fragment shader:  " + gl.getShaderInfoLog(fsh);
        }
        var prog = gl.createProgram();
        gl.attachShader(prog, vsh);
        gl.attachShader(prog, fsh);
        gl.linkProgram(prog);
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
          throw "Link error in program:  " + gl.getProgramInfoLog(prog);
        }
        return prog;
      }

      /* Initialize the WebGL context.  Called from init() */
      function initGL(fshader) {
        var prog = createProgram(gl, "vshader-source", fshader);
        gl.useProgram(prog);
        gl.enable(gl.DEPTH_TEST);

        /* Get attribute and uniform locations */

        a_coords_loc = gl.getAttribLocation(prog, "a_coords");
        a_normal_loc = gl.getAttribLocation(prog, "a_normal");
        a_texcoords_loc = gl.getAttribLocation(prog, "a_texCoords");
        gl.enableVertexAttribArray(a_coords_loc);
        gl.enableVertexAttribArray(a_normal_loc);
        gl.enableVertexAttribArray(a_texcoords_loc);

        u_modelview = gl.getUniformLocation(prog, "modelview");
        u_projection = gl.getUniformLocation(prog, "projection");
        u_normalMatrix = gl.getUniformLocation(prog, "normalMatrix");
        u_texture = gl.getUniformLocation(prog, "texture");
        gl.uniform1i(u_texture, 0);
        texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        u_material = {
          diffuseColor: gl.getUniformLocation(prog, "material.diffuseColor"),
          specularColor: gl.getUniformLocation(prog, "material.specularColor"),
          emissiveColor: gl.getUniformLocation(prog, "material.emissiveColor"),
          specularExponent: gl.getUniformLocation(prog, "material.specularExponent")
        };
        u_lights = new Array(4);
        for (var i = 0; i < 4; i++) {
          u_lights[i] = {
            enabled: gl.getUniformLocation(prog, "lights[" + i + "].enabled"),
            position: gl.getUniformLocation(prog, "lights[" + i + "].position"),
            color: gl.getUniformLocation(prog, "lights[" + i + "].color")
          };
        }

        gl.uniform3f(u_material.specularColor, 0.1, 0.1, 0.1);  // specular properties don't change
        gl.uniform1f(u_material.specularExponent, 16);
        gl.uniform3f(u_material.emissiveColor, 0, 0, 0);  // default, will be changed temporarily for some objects

        for (var i = 1; i < 4; i++) { // set defaults for lights
          gl.uniform1i(u_lights[i].enabled, 0);
          gl.uniform4f(u_lights[i].position, 0, 0, 1, 0);
          gl.uniform3f(u_lights[i].color, 1, 1, 1);
        }
        
        // Lights are set on in the draw() method
      } // end initGL()

      //--------------------------------- animation framework ------------------------------

      var animating = false;

      /*
      This is where you control the animation by changing positions,
      and rotations values as needed.
      Trial and error works on the numbers. Graph paper design is more efficient.
      */

      function frame() {
        if (animating) {
          frameNumber += 1;
          // Setting rotation position for fish
          fishRotation -= Math.PI / 180;

          // Setting rotation position for Sun
          sunRotation += Math.PI / 540;

          // Setting rotation position for Clouds
          cloudRotation -= Math.PI / 360;

          // Setting y-component for objects bobbing in water
          bobDistance = Math.sin(frameNumber / 30) * 0.2;

          draw();
          requestAnimationFrame(frame);
        }
      }

      function setAnimating() {
        var anim = document.getElementById("animCheck").checked;
        if (anim != animating) {
          animating = anim;
          if (animating)
            requestAnimationFrame(frame);
        }
      }

      function textureChoose() {
        if (document.getElementById("texture").value == 0) {
          try {
            initGL("fshader-source"); // initialize the WebGL graphics context
          }
          catch (e) {
            document.getElementById("message").innerHTML =
              "<p>Sorry, could not initialize the WebGL graphics context:" + e + "</p>";
            return;
          }
          loadTexture(0);
        }
        else {
          try {
            initGL("fshader-source-t"); // initialize the WebGL graphics context
          }
          catch (e) {
            document.getElementById("message").innerHTML =
              "<p>Sorry, could not initialize the WebGL graphics context:" + e + "</p>";
            return;
          }
          switch (document.getElementById("texture").value) {
            case '1':
              loadTexture(0);
              break;
            case '2':
              loadTexture(1);
              break;
            case '3':
              loadTexture(2);
              break;
          }
        }  
      }

      //-------------------------------------------------------------------------

      /**
       * initialization function that will be called when the page has loaded
       */
      function init() {

        try {
          var canvas = document.getElementById("webglcanvas");
          gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
          if (!gl) {
            throw "Browser does not support WebGL";
          }
        }
        catch (e) {
          document.getElementById("message").innerHTML =
            "<p>Sorry, could not get a WebGL graphics context.</p>";
          return;
        }
        
        textureChoose();
        // Setting Radio buttons/Checkboxes to be responsive
        document.getElementById("animCheckOff").checked = true;
        document.getElementById("animCheck").onchange = setAnimating;
        document.getElementById("animCheckOff").onchange = setAnimating;
        document.getElementById("sunlight").checked = true;
        document.getElementById("sunlight").onchange = () => {sunlight = !sunlight; draw();};
        document.getElementById("waterlight").checked = true;
        document.getElementById("waterlight").onchange = () => {waterlight = !waterlight; draw();};
        document.getElementById("texture").onchange = textureChoose;
        
        // Not really using all of these
        // As you create your scene use these or create from primitives
        torus = createModel(uvTorus(0.5, 1, 16, 8)); // Create all the basic objects.
        sphere = createModel(uvSphere(1));
        cone = createModel(uvCone(), [0, 0, 0.5]);
        cylinder = createModel(uvCylinder(), [0, 0, 1.5]);
        disk = createModel(uvCylinder(5.5, 0.5, 64), [0, 0, 0.25]);
        ring = createModel(ring(3.3, 4.8, 40));
        cube = createModel(cube());

        // This controls the zoom and initial placement
        rotator = new TrackballRotator(canvas, function () {
            if (!animating)
              draw();
          },17,[0, 1, 2]);
        draw();
      }

    </script>
  </head>
  <body onload="init()">
    <h2>Sea Scene - John Kucera</h2>

    <noscript>
      <hr />
        <h3>This page requires Javascript and a web browser that supports WebGL</h3>
      <hr
    /></noscript>

    <p id="message"><b>Drag your mouse on the model to rotate it.</b></p>

    <p>
      <label><input type="radio" id="animCheck" name="animationAll" />Animation On</label>
      <label><input type="radio" id="animCheckOff" name="animationAll" />Animation Off</label>
    </p>

    <p>
      <label><input type="checkbox" id="sunlight" />Sunlight On / Off</label>
      <label><input type="checkbox" id="waterlight" />Waterlight On / Off</label>
    </p>

    <p>
      <label><b>Texture:</b> <select id="texture">
        <option value = "0" selected>None</option>
        <option value = "1">Lava</option>
        <option value = "2">Water</option>
        <option value = "3">Leaves</option>
      </select></label>
    </p>

    <div>
      <canvas width="700" height="700" id="webglcanvas"></canvas>
    </div>
  </body>
</html>